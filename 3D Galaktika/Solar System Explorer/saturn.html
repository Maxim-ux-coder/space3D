<!DOCTYPE html>
<html lang="hy">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>’ç’°’ø’∏÷Ç÷Ä’∂’´ ’°’æ’ø’∏’¥’°’ø ’°’º’°÷Ñ’•’¨’∏÷Ç’©’µ’∏÷Ç’∂’®</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* General Styling for a Space/Sci-Fi look */
        body {
            background-color: #000000;
            font-family: 'Inter', sans-serif;
            color: #d1d5db;
            overflow: hidden;
        }
        /* Canvas Container */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* HUD (Heads-Up Display) Panel Styling */
        .hud-panel {
            position: absolute;
            z-index: 10;
            padding: 1.5rem;
            color: #10b981;
            text-shadow: 0 0 5px rgba(16, 185, 129, 0.5);
            background-color: rgba(0, 0, 0, 0.85);
            border: 1px solid #10b981;
            box-shadow: 0 0 15px #10b981;
            border-radius: 0.5rem;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        /* Top Right Panel - Mission Status */
        #mission-status {
            top: 1rem;
            right: 1rem;
            max-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Mission Log - Centralized for Automated Text */
        #mission-log {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            min-height: 150px;
            text-align: center;
            opacity: 0;
            pointer-events: none;
        }
        /* Manual Scan Interaction Style */
        .manual-scan-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .manual-scan-item:hover {
            background-color: rgba(52, 211, 153, 0.1);
        }
    </style>
</head>
<body>
    <!-- 3D Canvas Container -->
    <div id="canvas-container">
        <canvas id="saturnCanvas"></canvas>
    </div>

    <!-- HUD Overlay - Mission Status (Top Right) -->
    <div id="mission-status" class="hud-panel w-72 opacity-100">
        <h2 class="text-xl font-bold mb-2 text-yellow-400 border-b border-yellow-400/50 pb-1">
            ‘±’å‘±’î‘µ‘º’à’í‘π’Ö‘±’Ü ‘ø‘±’ê‘≥‘±’é‘ª’É‘±‘ø
        </h2>
        <p class="text-xs mb-3 text-gray-400">‘±’æ’ø’∏’¥’°’ø ’Ω’Ø’°’∂’°’æ’∏÷Ä’¥’°’∂ ÷Å’´’Ø’¨</p>
        <div id="target-list" class="space-y-2 text-sm">
            <!-- Targets will be listed here -->
        </div>
        <button onclick="window.location.reload()" class="mt-4 w-full p-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded-md transition">
            ’é‘µ’ê’ç‘ø’ç‘µ‘º ‘±’å‘±’î‘µ‘º’à’í‘π’Ö’à’í’Ü‘∏
        </button>
    </div>

    <!-- HUD Overlay - Mission Log (Center) -->
    <div id="mission-log" class="hud-panel transition-opacity duration-500">
        <h2 id="log-title" class="text-2xl font-bold mb-3 text-white">’ç‘ø‘ª‘∂‘≤‚Ä§ ‘±’é’è’à’Ñ‘±’è ’ç‘ø‘±’Ü‘±’é’à’ê’à’í’Ñ</h2>
        <div id="log-content" class="text-base text-gray-300">
            <p>‘±’æ’ø’∏’¥’°’ø ’Ω’Ø’°’∂’°’æ’∏÷Ä’¥’°’∂ ’º’•’™’´’¥’® ’¥’´’°÷Å’æ’°’Æ ’ß÷â</p>
            <p class="mt-2 text-yellow-400 font-semibold">’Ñ’´’°÷Å’æ’∏÷Ç’¥ ’•’∂ ’ø’•’Ω’°’≠÷Å’´’Ø’´ ’°’∂’´’¥’°÷Å’´’°’∂’•÷Ä’®...</p>
        </div>
    </div>

<script>
// --- THREE.JS GLOBAL VARIABLES ---
let scene, camera, renderer, saturnGroup, controls;
let planet, ringsGroup, titan;

// Physical parameters
const SATURN_RADIUS = 1.0;
const AXIAL_TILT = 26.7 * Math.PI / 180;
const TITAN_ORBIT_RADIUS = 5.0;

// CAMERA ANIMATION VARIABLES
const ANIMATION_DURATION = 2000; // 2.0 seconds - When approaching the target
const ZOOM_DURATION = 1500;      // 1.5 seconds - When approaching the data panel
const SCAN_DURATION = 1500;      // 1.5 seconds - Scan animation time
const READ_DURATION = 5000;      // 5.0 seconds - 5 seconds PAUSE AFTER TYPING TEXT

const CAMERA_ZOOM_DISTANCE = 6.0;
// ** ’à’í’Ç’Ç’à’í’Ñ **: ‘±’æ’•’¨’°÷Å’æ’•’¨ ’ß ’∂’∏÷Ä ’∞’°’Ω’ø’°’ø’∏÷Ç’∂’ù ’±’•’º÷Ñ’∏’æ ’Ω’Ø’°’∂’°’æ’∏÷Ä’¥’°’∂ ’™’°’¥’°’∂’°’Ø ’ø’•’Ω’°’≠÷Å’´’Ø’´ ’°’æ’•’¨’´ ’¥’∏’ø ’§’´÷Ä÷Ñ’´ ’∞’°’¥’°÷Ä÷â
const MANUAL_CAMERA_ZOOM_DISTANCE = 4.0;


let cameraAnimation = null;
let typewriterInterval = null;

// --- MISSION STATUS ---
let missionState = 'idle'; // 'idle', 'animating', 'scanning', 'reading', 'complete'
let currentTargetIndex = 0;
let targets = [];
let dataPanel3D = null;
let scanningLine3D = null;

const TARGET_DATA = [
    {
        id: 'Hexagon',
        name: "’é’•÷Å’°’∂’Ø’µ’∏÷Ç’∂",
        status: "’â’ç‘ø‘±’Ü‘±’é’à’ê’é‘±‘æ",
        pos: new THREE.Vector3(0, SATURN_RADIUS * 1.05, 0).applyAxisAngle(new THREE.Vector3(1, 0, 0), AXIAL_TILT),
        info: `’é‘µ’ë‘±’Ü‘ø’Ö’à’í’Ü

’ç’° ’°’¥’∫’•÷Ä’´ ’∞’∏’Ω÷Ñ’´ ’Ø’°’∂’£’∏÷Ç’∂ ’°’¨’´÷Ñ’´ ’µ’∏÷Ç÷Ä÷Ö÷Ä’´’∂’°’Ø ’•÷Ä’Ø÷Ä’°’π’°÷É’°’Ø’°’∂ ’Ø’°’º’∏÷Ç÷Å’æ’°’Æ÷Ñ ’ß’ù ’ø’•’≤’°’Ø’°’µ’æ’°’Æ ’ç’°’ø’∏÷Ç÷Ä’∂’´ ’∞’µ’∏÷Ç’Ω’´’Ω’°’µ’´’∂ ’¢÷á’•’º’´ ’∑’∏÷Ç÷Ä’ª÷â ’Ö’∏÷Ç÷Ä’°÷Ñ’°’∂’π’µ’∏÷Ç÷Ä ’Ø’∏’≤’¥’´ ’•÷Ä’Ø’°÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ’¥’∏’ø 13,800 ’Ø’¥ ’ß÷â

’Ä’´’¥’∂’°’Ø’°’∂ ’∫’°÷Ä’°’¥’•’ø÷Ä’•÷Ä:
- ’è’•’Ω’°’Ø: ’Ñ’©’∂’∏’¨’∏÷Ä’ø’°’µ’´’∂ ’Ø’°’∂’£’∏÷Ç’∂ ’°’¨’´÷Ñ
- ‘≥’ø’∂’æ’•’¨’∏÷Ç ’æ’°’µ÷Ä: ’Ä’µ’∏÷Ç’Ω’´’Ω’°’µ’´’∂ ’¢÷á’•’º
- ’ä’ø’ø’¥’°’∂ ’∫’°÷Ä’¢’•÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: 10.5 ’™’°’¥
- ’Ñ’´’ª’´’∂ ’ø÷Ä’°’¥’°’£’´’Æ: 25,000 ’Ø’¥`,
        cameraOffset: new THREE.Vector3(0, 3, 3),
        isPlanetTarget: true
    },
    {
        id: 'CassiniDivision',
        name: "‘ø’°’Ω’´’∂’´’´ ’¢’°’™’°’∂’∏÷Ç’¥",
        status: "’â’ç‘ø‘±’Ü‘±’é’à’ê’é‘±‘æ",
        pos: new THREE.Vector3(3.125 * SATURN_RADIUS, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 4),
        info: `‘ø‘±’ç‘ª’Ü‘ª‘ª ‘≤‘±‘∫‘±’Ü’à’í’Ñ

’Ä’°’µ’ø’∂’°’¢’•÷Ä’•’¨ ’ß ’ã’∏’æ’°’∂’´ ‘ø’°’Ω’´’∂’´’∂ 1675 ’©’æ’°’Ø’°’∂’´’∂÷â ‘±’µ’Ω ’¢’°÷Å’® ’∫’°’µ’¥’°’∂’°’æ’∏÷Ä’æ’°’Æ ’ß ’ç’°’ø’∏÷Ç÷Ä’∂’´ ’Ñ’´’¥’°’Ω ’°÷Ä’¢’°’∂’µ’°’Ø’´ ’±’£’∏’≤’°’Ø’°’∂ ’°’¶’§’•÷Å’∏÷Ç’©’µ’°’¥’¢÷â

’Ä’´’¥’∂’°’Ø’°’∂ ’∫’°÷Ä’°’¥’•’ø÷Ä’•÷Ä:
- ’è’•’Ω’°’Ø: ’ï’≤’°’Ø’∂’•÷Ä’´ ’¢’°÷Å/’¢’°’™’°’∂’∏÷Ç’¥
- ‘≥’ø’∂’æ’•’¨’∏÷Ç ’æ’°’µ÷Ä: A ÷á B ÷Ö’≤’°’Ø’∂’•÷Ä’´ ’¥’´’ª÷á
- ‘º’°’µ’∂’∏÷Ç’©’µ’∏÷Ç’∂: ’Ñ’∏’ø 4,800 ’Ø’¥
- ’ä’°’ø’≥’°’º: ’Ñ’´’¥’°’Ω’´ 2:1 ’∏÷Ç’≤’•’Æ÷Ä’°’µ’´’∂ ’º’•’¶’∏’∂’°’∂’Ω
- ’Ä’°’µ’ø’∂’°’¢’•÷Ä’∏÷Ç’¥: 1675 ’©.`,
        // ** ’à’í’Ç’Ç’à’í’Ñ **: ’ì’∏’≠’æ’•’¨ ’ß ’ø’•’Ω’°’≠÷Å’´’Ø’´ ’§’´÷Ä÷Ñ’®’ù ’ø’•’Ω’°’∂’•’¨’´’∏÷Ç’©’µ’∏÷Ç’∂’® ’¢’°÷Ä’•’¨’°’æ’•’¨’∏÷Ç ’∞’°’¥’°÷Ä (’°’æ’•’¨’´ ’¢’°÷Ä’±÷Ä ÷á ’¥’´ ÷É’∏÷Ñ÷Ä ’∞’•’º’∏÷Ç)÷â
        cameraOffset: new THREE.Vector3(4, 1.5, 3),
        isPlanetTarget: true
    },
    {
        id: 'Titan',
        name: "’è’´’ø’°’∂ ’°÷Ä’¢’°’∂’µ’°’Ø",
        status: "’â’ç‘ø‘±’Ü‘±’é’à’ê’é‘±‘æ",
        pos: new THREE.Vector3(TITAN_ORBIT_RADIUS, 0, 0),
        info: `’è‘ª’è‘±’Ü

’è’´’ø’°’∂’® ’ç’°’ø’∏÷Ç÷Ä’∂’´ ’°’¥’•’∂’°’¥’•’Æ ’°÷Ä’¢’°’∂’µ’°’Ø’∂ ’ß ÷á ’•÷Ä’Ø÷Ä’∏÷Ä’§’®’ù ‘±÷Ä’•’£’°’Ø’∂’°’µ’´’∂ ’∞’°’¥’°’Ø’°÷Ä’£’∏÷Ç’¥÷â ‘±’µ’∂ ’¥’´’°’Ø ’∞’°’µ’ø’∂’´ ’°÷Ä’¢’°’∂’µ’°’Ø’∂ ’ß, ’∏÷Ä’∂ ’∏÷Ç’∂’´ ’≠’´’ø ’¥’©’∂’∏’¨’∏÷Ä’ø, ’´’∂’π’∫’•’Ω ’∂’°÷á ’∞’•’≤’∏÷Ç’Ø’´ ’¥’°÷Ä’¥’´’∂’∂’•÷Ä ’´÷Ä ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´’∂÷â

’Ä’´’¥’∂’°’Ø’°’∂ ’∫’°÷Ä’°’¥’•’ø÷Ä’•÷Ä:
- ’è’•’Ω’°’Ø: ’ç’°’º÷Å’• ’°÷Ä’¢’°’∂’µ’°’Ø ’≠’´’ø ’¥’©’∂’∏’¨’∏÷Ä’ø’∏’æ
- ’Ñ’©’∂’∏’¨’∏÷Ä’ø: ‘±’¶’∏’ø (95%), ’Ñ’•’©’°’∂ (4.9%)
- ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’∞’•’≤’∏÷Ç’Ø’∂’•÷Ä: ’Ä’•’≤’∏÷Ç’Ø ’¥’•’©’°’∂/’ß’©’°’∂
- ’ã’•÷Ä’¥’°’Ω’ø’´’≥’°’∂: ’Ñ’´’ª’´’∂’® -179¬∞C
- ’è÷Ä’°’¥’°’£’´’Æ: 5,150 ’Ø’¥`,
        // ** ’à’í’Ç’Ç’à’í’Ñ **: ’ì’∏’≠’æ’•’¨ ’ß ’ø’•’Ω’°’≠÷Å’´’Ø’´ ’§’´÷Ä÷Ñ’®’ù ’°’æ’•’¨’´ ’≥’´’∑’ø ’°’∂’Ø’µ’∏÷Ç’∂ ’°’∫’°’∞’∏’æ’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â
        cameraOffset: new THREE.Vector3(2, 2, 3),
        isPlanetTarget: false
    }
];

// --- TWEEN PERFORMANCE (For Self-Contained Animation) ---
var TWEEN = {
    _tweens: [],
    add: function(tween) { this._tweens.push(tween); },
    update: function(time) {
        if (this._tweens.length === 0) return false;
        var i = 0;
        while (i < this._tweens.length) {
            if (this._tweens[i].update(time)) { i++; }
            else { this._tweens.splice(i, 1); }
        }
        return true;
    }
};
TWEEN.Tween = function(object) {
    this._object = object; this._valuesStart = {}; this._valuesEnd = {};
    this._duration = 1000; this._startTime = 0; this._onCompleteCallback = null;
    this.to = function(properties, duration) {
        this._valuesEnd = properties;
        if (duration !== undefined) this._duration = duration;
        return this;
    };
    this.start = function(time) {
        TWEEN.add(this);
        this._startTime = time !== undefined ? time : Date.now();
        for (var property in this._valuesEnd) {
            if (this._object[property] !== undefined) {
                this._valuesStart[property] = this._object[property];
            }
        }
        return this;
    };
    this.onComplete = function(callback) { this._onCompleteCallback = callback; return this; };
    this.update = function(time) {
        var property, elapsed, progress, value;
        if (time < this._startTime) return true;
        elapsed = time - this._startTime;
        progress = elapsed / this._duration;
        progress = progress > 1 ? 1 : progress;
        progress = progress * progress * (3 - 2 * progress); // Smoothstep
        for (property in this._valuesEnd) {
            value = this._valuesStart[property] + (this._valuesEnd[property] - this._valuesStart[property]) * progress;
            this._object[property] = value;
        }
        if (progress === 1) {
            if (this._onCompleteCallback !== null) { this._onCompleteCallback(this._object); }
            return false;
        }
        return true;
    };
};

// --- INITIALIZATION ---
function initSaturn3D() {
    const container = document.getElementById('canvas-container');
    const canvas = document.getElementById('saturnCanvas');
    const width = container.clientWidth;
    const height = container.clientHeight;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(0, 8, 10);

    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(width, height);
    window.addEventListener('resize', onWindowResize);
    onWindowResize();

    const directionalLight = new THREE.DirectionalLight(0xffffff, 4.0);
    directionalLight.position.set(10, 5, 10);
    scene.add(directionalLight);
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambientLight);

    saturnGroup = new THREE.Group();
    saturnGroup.rotation.x = AXIAL_TILT;
    scene.add(saturnGroup);

    const planetGeometry = new THREE.SphereGeometry(SATURN_RADIUS, 64, 64);
    const planetMaterial = new THREE.MeshStandardMaterial({ color: 0xe0c46b, roughness: 0.9, metalness: 0.1 });
    planet = new THREE.Mesh(planetGeometry, planetMaterial);
    saturnGroup.add(planet);

    ringsGroup = new THREE.Group();
    saturnGroup.add(ringsGroup);
    const createRing = (innerRadius, outerRadius, color, opacity) => {
        const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 128);
        ringGeometry.rotateX(Math.PI / 2);
        const ringMaterial = new THREE.MeshStandardMaterial({
            color: color, side: THREE.DoubleSide, transparent: true,
            opacity: opacity, roughness: 0.9,
        });
        ringsGroup.add(new THREE.Mesh(ringGeometry, ringMaterial));
    };
    createRing(1.2 * SATURN_RADIUS, 1.8 * SATURN_RADIUS, 0xd0d0d0, 0.4);
    createRing(1.9 * SATURN_RADIUS, 3.0 * SATURN_RADIUS, 0xb89467, 0.9);
    createRing(3.25 * SATURN_RADIUS, 4.0 * SATURN_RADIUS, 0xe0e0e0, 0.7);

    const titanGeometry = new THREE.SphereGeometry(0.2, 32, 32);
    const titanMaterial = new THREE.MeshStandardMaterial({ color: 0xcc9966, roughness: 0.9 });
    titan = new THREE.Mesh(titanGeometry, titanMaterial);
    titan.position.copy(TARGET_DATA.find(t => t.id === 'Titan').pos);
    saturnGroup.add(titan);

    createTargets();

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.minDistance = 2.5; controls.maxDistance = 15;
    controls.target.set(0, 0, 0);
    controls.enabled = false;
    controls.update();

    updateMissionStatusUI();
    setTimeout(startMission, 2000);
}

function createTargets() {
    const markerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444, wireframe: true, opacity: 0.8, transparent: true });
    TARGET_DATA.forEach(data => {
        if (data.id === 'Titan') return; // Titan object is created separately
        const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
        marker.position.copy(data.pos);
        marker.userData = { id: data.id };
        saturnGroup.add(marker);
        targets.push(marker);
    });
}

// --- FUNCTIONS OF CAMERA ANIMATION ---
function updateCameraAnimation() {
    if (!cameraAnimation) return;
    const elapsed = Date.now() - cameraAnimation.startTime;
    let t = Math.min(1, elapsed / cameraAnimation.duration);
    t = t * t * (3 - 2 * t); // Smoothstep
    camera.position.lerpVectors(cameraAnimation.startPos, cameraAnimation.endPos, t);
    const currentLookAt = new THREE.Vector3().lerpVectors(cameraAnimation.startLookAt, cameraAnimation.endLookAt, t);
    controls.target.copy(currentLookAt);
    controls.update();
    if (t >= 1) {
        const callback = cameraAnimation.onComplete;
        cameraAnimation = null;
        if (callback) callback();
    }
}

function startCameraAnimation(targetPosition, lookAtPosition, duration, onComplete) {
    cameraAnimation = {
        startTime: Date.now(),
        duration: duration,
        startPos: camera.position.clone(),
        endPos: targetPosition.clone(),
        startLookAt: controls.target.clone(),
        endLookAt: lookAtPosition.clone(),
        onComplete: onComplete
    };
}

// --- 3D DATA PANEL (HOLOGRAM) ---
function clear3DDataPanel() {
    if (typewriterInterval) {
        clearInterval(typewriterInterval);
        typewriterInterval = null;
    }
    if (dataPanel3D) {
        if (dataPanel3D.parent) {
            dataPanel3D.parent.remove(dataPanel3D);
        }
        if (dataPanel3D.material.map) dataPanel3D.material.map.dispose();
        dataPanel3D.material.dispose();
        dataPanel3D = null;
    }
}

function create3DDataPanel(position, dataInfo, onCompleteTyping) {
    clear3DDataPanel();
    const panelWidth = 4.0;
    const panelHeight = 3.5;
    const aspect = panelHeight / panelWidth;
    const canvas = document.createElement('canvas');
    const size = 1024;
    canvas.width = size;
    canvas.height = size * aspect;
    const context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 40, 0.85)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.strokeStyle = '#34d399';
    context.lineWidth = 15;
    context.strokeRect(0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.0, depthTest: false });
    dataPanel3D = new THREE.Sprite(material);
    dataPanel3D.scale.set(panelWidth, panelHeight, 1);

    const offset = new THREE.Vector3(2.5, 0.5, 0);
    dataPanel3D.position.copy(position.clone().add(offset));
    saturnGroup.add(dataPanel3D);

    new TWEEN.Tween(dataPanel3D.material).to({ opacity: 1 }, 500).start(Date.now());
    typewriterEffect(dataPanel3D, dataInfo, context, size, panelWidth, panelHeight, onCompleteTyping);
}


function typewriterEffect(sprite, fullText, context, canvasSize, panelWidth, panelHeight, onComplete) {
    const padding = 50;
    const lineHeightPx = 40;
    const fontSize = '24pt';
    context.font = `bold ${fontSize} Inter, sans-serif`;

    const maxWidth = canvasSize - padding * 2;
    const contentHeightPx = canvasSize * (panelHeight / panelWidth) - padding * 2;

    const paragraphs = fullText.trim().replace(/\r/g, '').split('\n');
    let lines = [];

    paragraphs.forEach(paragraph => {
        let words = paragraph.trim().split(/\s+/);
        if (words.length === 1 && words[0] === '') {
            lines.push('');
            return;
        }
        let currentLine = '';
        words.forEach(word => {
            let testLine = currentLine + word + ' ';
            if (context.measureText(testLine).width > maxWidth && currentLine.length > 0) {
                lines.push(currentLine.trim());
                currentLine = word + ' ';
            } else {
                currentLine = testLine;
            }
        });
        lines.push(currentLine.trim());
    });

    const maxLines = Math.floor(contentHeightPx / lineHeightPx) - 1;
    if (lines.length > maxLines) {
        lines = lines.slice(0, maxLines);
        if (lines[maxLines - 1] && lines[maxLines - 1].length > 3) {
            lines[maxLines - 1] = lines[maxLines - 1].substring(0, lines[maxLines - 1].length - 3) + '...';
        }
    }

    let lineIndex = 0;
    let charIndex = 0;

    const renderText = () => {
        context.clearRect(padding, padding, maxWidth, contentHeightPx);
        context.fillStyle = 'rgba(10, 20, 40, 0.85)';
        context.fillRect(padding, padding, maxWidth, contentHeightPx);
        context.font = `bold ${fontSize} Inter, sans-serif`;
        context.fillStyle = '#34d399'; // Animation uses a bright color
        context.textAlign = 'left';

        let y = padding + lineHeightPx * 0.8;
        for (let i = 0; i <= lineIndex && i < lines.length; i++) {
            let textToWrite = lines[i];
            if (i === lineIndex) {
                textToWrite = textToWrite.substring(0, charIndex);
            }
            context.fillText(textToWrite, padding, y);
            y += lineHeightPx;
        }
        sprite.material.map.needsUpdate = true;
    };

    typewriterInterval = setInterval(() => {
        if (lineIndex >= lines.length) {
            clearInterval(typewriterInterval);
            typewriterInterval = null;

            // ** ’à’í’Ç’Ç’à’í’Ñ **: ‘µ÷Ä’¢ ’£÷Ä’•’¨’∂ ’°’æ’°÷Ä’ø’æ’∏÷Ç’¥ ’ß, ’æ’•÷Ä’ª’∂’°’Ø’°’∂ ’ø’•÷Ñ’Ω’ø’® ’∂’Ø’°÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’°’æ’•’¨’´ ’¥’∏÷Ç’£, ’®’∂’©’•’º’∂’•’¨’´ ’£’∏÷Ç’µ’∂’∏’æ÷â
            context.clearRect(padding, padding, maxWidth, contentHeightPx);
            context.fillStyle = 'rgba(10, 20, 40, 0.85)';
            context.fillRect(padding, padding, maxWidth, contentHeightPx);
            context.font = `bold ${fontSize} Inter, sans-serif`;
            context.fillStyle = '#10b981'; // Darker, more readable color
            context.textAlign = 'left';
            let y = padding + lineHeightPx * 0.8;
            for (let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], padding, y);
                y += lineHeightPx;
            }
            sprite.material.map.needsUpdate = true;


            if (onComplete) onComplete();
            return;
        }

        if (charIndex < (lines[lineIndex] ? lines[lineIndex].length : 0)) {
            charIndex++;
        } else {
            charIndex = 0;
            lineIndex++;
        }
        renderText();

        if (lineIndex >= lines.length) {
            clearInterval(typewriterInterval);
            typewriterInterval = null;
            if (onComplete) onComplete();
        }
    }, 30);
}


function createScanningLine(targetPosition) {
    if (scanningLine3D) saturnGroup.remove(scanningLine3D);
    const length = 1.5;
    const height = 0.05;
    const lineGeometry = new THREE.BoxGeometry(length, height, height);
    const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff4444, transparent: true, opacity: 0.9 });
    scanningLine3D = new THREE.Mesh(lineGeometry, lineMaterial);
    scanningLine3D.position.copy(targetPosition);
    scanningLine3D.rotation.z = Math.PI / 4;
    scanningLine3D.scale.set(0.001, 1, 1);
    saturnGroup.add(scanningLine3D);

    new TWEEN.Tween(scanningLine3D.scale).to({ x: 1.0, y: 1.0, z: 1.0 }, SCAN_DURATION).start(Date.now());
    const diagonalOffset = length * 0.5;
    new TWEEN.Tween(scanningLine3D.position).to({
        x: targetPosition.x + diagonalOffset * Math.cos(Math.PI / 4),
        y: targetPosition.y + diagonalOffset * Math.sin(Math.PI / 4),
        z: targetPosition.z
    }, SCAN_DURATION).start(Date.now());
}

// --- MISSION MANAGEMENT LOGIC ---
function startMission() {
    document.getElementById('mission-log').style.opacity = '0';
    document.getElementById('mission-status').style.opacity = '1';
    if (currentTargetIndex < TARGET_DATA.length) {
        processTarget(TARGET_DATA[currentTargetIndex], false);
    } else {
        missionComplete();
    }
}

function processTarget(target, isManual = false) {
    let targetObject = target.id === 'Titan' ? titan : targets.find(t => t.userData.id === target.id);
    if (!targetObject) return; // Exit if target not found
    
    const markerPosition = new THREE.Vector3();
    targetObject.getWorldPosition(markerPosition); // Use world position to handle rotation correctly

    missionState = isManual ? 'animating_manual' : 'animating';

    const lookAt = markerPosition.clone();
    const cameraOffset = target.cameraOffset.clone();
    // Since we use world position, we don't need to transform the offset
    const newCameraPosition = lookAt.clone().add(cameraOffset);

    startCameraAnimation(newCameraPosition, lookAt, ANIMATION_DURATION, () => {
        if (!isManual) {
            startScanning(target, markerPosition);
        } else {
            revealData(target, markerPosition, true);
        }
    });
}

function startScanning(target, position) {
    missionState = 'scanning';
    createScanningLine(position);
    document.getElementById('mission-status').style.opacity = '0';

    setTimeout(() => {
        if (scanningLine3D && scanningLine3D.parent) {
            scanningLine3D.parent.remove(scanningLine3D);
        }
        revealData(target, position, false);
    }, SCAN_DURATION);
}

function revealData(target, position, isManual) {
    missionState = isManual ? 'reading_manual' : 'reading';

    create3DDataPanel(position, target.info, () => {
        const panelWorldPos = new THREE.Vector3();
        if (!dataPanel3D) return;
        dataPanel3D.getWorldPosition(panelWorldPos);

        // ** ’à’í’Ç’Ç’à’í’Ñ **: ’ï’£’ø’°’£’∏÷Ä’Æ’æ’∏÷Ç’¥ ’ß isManual ÷É’∏÷É’∏’≠’°’Ø’°’∂’®’ù ’ø’•’Ω’°’≠÷Å’´’Ø’´ ’≥’´’∑’ø ’∞’•’º’°’æ’∏÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ’∏÷Ä’∏’∑’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â
        const zoomDistance = isManual ? MANUAL_CAMERA_ZOOM_DISTANCE : CAMERA_ZOOM_DISTANCE;
        const cameraDirection = new THREE.Vector3().subVectors(camera.position, panelWorldPos).normalize();
        const finalCameraPos = panelWorldPos.clone().add(cameraDirection.multiplyScalar(zoomDistance));

        startCameraAnimation(finalCameraPos, panelWorldPos, ZOOM_DURATION, () => {
            setTimeout(() => {
                document.getElementById('mission-log').style.opacity = '0';
                if (!isManual) {
                    finishTarget(target);
                } else {
                    finishManualScan();
                }
            }, READ_DURATION);
        });
    });
}


function finishTarget(target) {
    clear3DDataPanel();
    target.status = "’é‘µ’ê‘±‘ø‘±’Ü‘≥’Ü’é‘±‘æ";

    const marker = targets.find(m => m.userData.id === target.id);
    if (marker) marker.visible = false;

    updateMissionStatusUI();
    currentTargetIndex++;

    if (currentTargetIndex < TARGET_DATA.length) {
        startCameraAnimation(new THREE.Vector3(0, 8, 10), new THREE.Vector3(0, 0, 0), ANIMATION_DURATION / 2, () => {
            document.getElementById('mission-status').style.opacity = '1';
            startMission();
        });
    } else {
        missionComplete();
    }
}

function finishManualScan() {
    clear3DDataPanel();
    startCameraAnimation(new THREE.Vector3(0, 15, 15), new THREE.Vector3(0, 0, 0), 1000, () => {
        document.getElementById('mission-status').style.opacity = '1';
        missionState = 'complete';
        controls.enabled = true;
    });
}

function missionComplete() {
    missionState = 'complete';
    startCameraAnimation(new THREE.Vector3(0, 15, 15), new THREE.Vector3(0, 0, 0), 2000, () => {
        controls.enabled = true;
        document.getElementById('mission-status').style.opacity = '1';
    });

    document.getElementById('mission-log').style.opacity = '1';
    document.getElementById('log-title').textContent = '‘±’å‘±’î‘µ‘º’à’í‘π’Ö’à’í’Ü’Ü ‘±’é‘±’ê’è’é‘±‘æ ‘∑';
    document.getElementById('log-content').innerHTML = `
        <p class="text-xl font-extrabold text-green-400">’á’Ü’à’ê’Ä‘±’é’à’ê’à’í’Ñ ‘µ’Ü’î, ’Ä’ê‘±’Ñ‘±’Ü‘±’è‘±’ê÷â</p>
        <p class="mt-2">‘¥’∏÷Ç÷Ñ ’∞’°’ª’∏’≤’∏÷Ç’©’µ’°’¥’¢ ’æ’•÷Ä’°’Ø’°’∂’£’∂’•’¨ ’•÷Ñ ’ç’°’ø’∏÷Ç÷Ä’∂’´ ’∞’°’¥’°’Ø’°÷Ä’£’´ ’¢’∏’¨’∏÷Ä ’∞’´’¥’∂’°’Ø’°’∂ ’£’´’ø’°’Ø’°’∂ ’ø’æ’µ’°’¨’∂’•÷Ä’®÷â</p>
        <p class="mt-2 text-yellow-300">‘±’µ’™’¥ ’Ø’°÷Ä’∏’≤ ’•÷Ñ ’Ω’•’≤’¥’•’¨ ’°’ª ’¥’•’∂’µ’∏÷Ç’´ ’æ÷Ä’°’ù ’ø’æ’µ’°’¨’∂’•÷Ä’® ’Ø÷Ä’Ø’´’∂ ’§’´’ø’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â</p>
    `;

    setTimeout(() => {
        document.getElementById('mission-log').style.opacity = '0';
    }, READ_DURATION);
}

window.manualScan = function (targetId) {
    if (missionState !== 'complete' && missionState !== 'idle') return;
    controls.enabled = false;
    const target = TARGET_DATA.find(t => t.id === targetId);
    if (!target) return;
    
    let targetObject = target.id === 'Titan' ? titan : targets.find(t => t.userData.id === target.id);
    
    processTarget(target, true);
};

// --- UI UPDATE ---
function updateMissionStatusUI() {
    const list = document.getElementById('target-list');
    list.innerHTML = '';
    TARGET_DATA.forEach((data, index) => {
        const isCurrent = index === currentTargetIndex && missionState !== 'complete';
        const isCompleted = data.status === "’é‘µ’ê‘±‘ø‘±’Ü‘≥’Ü’é‘±‘æ";
        const statusColor = isCompleted ? 'text-green-500' : (isCurrent ? 'text-yellow-500' : 'text-red-500');
        const icon = isCompleted ? '‚úÖ' : (isCurrent ? 'üîÑ' : 'üî¥');
        const clickAction = isCompleted || missionState === 'complete' ? `onclick="manualScan('${data.id}')"` : '';
        const cursorStyle = isCompleted || missionState === 'complete' ? 'manual-scan-item' : 'cursor-default';
        const currentHighlight = isCurrent ? 'bg-yellow-800/20 border-l-2 border-yellow-500' : '';

        list.innerHTML += `
            <div class="p-2 rounded-md transition ${currentHighlight} ${cursorStyle}" ${clickAction}>
                <p class="font-bold">${icon} ${data.name}</p>
                <p class="text-xs ml-6 ${statusColor}">${data.status}</p>
            </div>
        `;
    });
}

function onWindowResize() {
    const container = document.getElementById('canvas-container');
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
}

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now();
    TWEEN.update(time);
    updateCameraAnimation();
    if (controls.enabled) {
        controls.update();
    }
    saturnGroup.rotation.y += 0.0005;
    ringsGroup.rotation.z -= 0.0001;
    titan.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.001);
    renderer.render(scene, camera);
}

initSaturn3D();
animate();

</script>
</body>
</html>