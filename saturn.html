<!DOCTYPE html>
<html lang="hy">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Սատուրնի ավտոմատ առաքելությունը</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* General Styling for a Space/Sci-Fi look */
        body {
            background-color: #000000;
            font-family: 'Inter', sans-serif;
            color: #d1d5db;
            overflow: hidden;
        }
        /* Canvas Container */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* HUD (Heads-Up Display) Panel Styling */
        .hud-panel {
            position: absolute;
            z-index: 10;
            padding: 1.5rem;
            color: #10b981;
            text-shadow: 0 0 5px rgba(16, 185, 129, 0.5);
            background-color: rgba(0, 0, 0, 0.85);
            border: 1px solid #10b981;
            box-shadow: 0 0 15px #10b981;
            border-radius: 0.5rem;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        /* Top Right Panel - Mission Status */
        #mission-status {
            top: 1rem;
            right: 1rem;
            max-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Mission Log - Centralized for Automated Text */
        #mission-log {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            min-height: 150px;
            text-align: center;
            opacity: 0;
            pointer-events: none;
        }
        /* Manual Scan Interaction Style */
        .manual-scan-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .manual-scan-item:hover {
            background-color: rgba(52, 211, 153, 0.1);
        }
    </style>
</head>
<body>
    <!-- 3D Canvas Container -->
    <div id="canvas-container">
        <canvas id="saturnCanvas"></canvas>
    </div>

    <!-- HUD Overlay - Mission Status (Top Right) -->
    <div id="mission-status" class="hud-panel w-72 opacity-100">
        <h2 class="text-xl font-bold mb-2 text-yellow-400 border-b border-yellow-400/50 pb-1">
            ԱՌԱՔԵԼՈՒԹՅԱՆ ԿԱՐԳԱՎԻՃԱԿ
        </h2>
        <p class="text-xs mb-3 text-gray-400">Ավտոմատ սկանավորման ցիկլ</p>
        <div id="target-list" class="space-y-2 text-sm">
            <!-- Targets will be listed here -->
        </div>
        <button onclick="window.location.reload()" class="mt-4 w-full p-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded-md transition">
            ՎԵՐՍԿՍԵԼ ԱՌԱՔԵԼՈՒԹՅՈՒՆԸ
        </button>
    </div>

    <!-- HUD Overlay - Mission Log (Center) -->
    <div id="mission-log" class="hud-panel transition-opacity duration-500">
        <h2 id="log-title" class="text-2xl font-bold mb-3 text-white">ՍԿԻԶԲ․ ԱՎՏՈՄԱՏ ՍԿԱՆԱՎՈՐՈՒՄ</h2>
        <div id="log-content" class="text-base text-gray-300">
            <p>Ավտոմատ սկանավորման ռեժիմը միացված է։</p>
            <p class="mt-2 text-yellow-400 font-semibold">Միացվում են տեսախցիկի անիմացիաները...</p>
        </div>
    </div>

<script>
// --- THREE.JS GLOBAL VARIABLES ---
let scene, camera, renderer, saturnGroup, controls;
let planet, ringsGroup, titan;

// Physical parameters
const SATURN_RADIUS = 1.0;
const AXIAL_TILT = 26.7 * Math.PI / 180;
const TITAN_ORBIT_RADIUS = 5.0;

// CAMERA ANIMATION VARIABLES
const ANIMATION_DURATION = 2000; // 2.0 seconds - When approaching the target
const ZOOM_DURATION = 1500;      // 1.5 seconds - When approaching the data panel
const SCAN_DURATION = 1500;      // 1.5 seconds - Scan animation time
const READ_DURATION = 5000;      // 5.0 seconds - 5 seconds PAUSE AFTER TYPING TEXT

const CAMERA_ZOOM_DISTANCE = 6.0;
// ** ՈՒՂՂՈՒՄ **: Ավելացվել է նոր հաստատուն՝ ձեռքով սկանավորման ժամանակ տեսախցիկի ավելի մոտ դիրքի համար։
const MANUAL_CAMERA_ZOOM_DISTANCE = 4.0;


let cameraAnimation = null;
let typewriterInterval = null;

// --- MISSION STATUS ---
let missionState = 'idle'; // 'idle', 'animating', 'scanning', 'reading', 'complete'
let currentTargetIndex = 0;
let targets = [];
let dataPanel3D = null;
let scanningLine3D = null;

const TARGET_DATA = [
    {
        id: 'Hexagon',
        name: "Վեցանկյուն",
        status: "ՉՍԿԱՆԱՎՈՐՎԱԾ",
        pos: new THREE.Vector3(0, SATURN_RADIUS * 1.05, 0).applyAxisAngle(new THREE.Vector3(1, 0, 0), AXIAL_TILT),
        info: `ՎԵՑԱՆԿՅՈՒՆ

Սա ամպերի հոսքի կանգուն ալիքի յուրօրինակ երկրաչափական կառուցվածք է՝ տեղակայված Սատուրնի հյուսիսային բևեռի շուրջ։ Յուրաքանչյուր կողմի երկարությունը մոտ 13,800 կմ է։

Հիմնական պարամետրեր:
- Տեսակ: Մթնոլորտային կանգուն ալիք
- Գտնվելու վայր: Հյուսիսային բևեռ
- Պտտման պարբերություն: 10.5 ժամ
- Միջին տրամագիծ: 25,000 կմ`,
        cameraOffset: new THREE.Vector3(0, 3, 3),
        isPlanetTarget: true
    },
    {
        id: 'CassiniDivision',
        name: "Կասինիի բաժանում",
        status: "ՉՍԿԱՆԱՎՈՐՎԱԾ",
        pos: new THREE.Vector3(3.125 * SATURN_RADIUS, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 4),
        info: `ԿԱՍԻՆԻԻ ԲԱԺԱՆՈՒՄ

Հայտնաբերել է Ջովանի Կասինին 1675 թվականին։ Այս բացը պայմանավորված է Սատուրնի Միմաս արբանյակի ձգողական ազդեցությամբ։

Հիմնական պարամետրեր:
- Տեսակ: Օղակների բաց/բաժանում
- Գտնվելու վայր: A և B օղակների միջև
- Լայնություն: Մոտ 4,800 կմ
- Պատճառ: Միմասի 2:1 ուղեծրային ռեզոնանս
- Հայտնաբերում: 1675 թ.`,
        // ** ՈՒՂՂՈՒՄ **: Փոխվել է տեսախցիկի դիրքը՝ տեսանելիությունը բարելավելու համար (ավելի բարձր և մի փոքր հեռու)։
        cameraOffset: new THREE.Vector3(4, 1.5, 3),
        isPlanetTarget: true
    },
    {
        id: 'Titan',
        name: "Տիտան արբանյակ",
        status: "ՉՍԿԱՆԱՎՈՐՎԱԾ",
        pos: new THREE.Vector3(TITAN_ORBIT_RADIUS, 0, 0),
        info: `ՏԻՏԱՆ

Տիտանը Սատուրնի ամենամեծ արբանյակն է և երկրորդը՝ Արեգակնային համակարգում։ Այն միակ հայտնի արբանյակն է, որն ունի խիտ մթնոլորտ, ինչպես նաև հեղուկի մարմիններ իր մակերևույթին։

Հիմնական պարամետրեր:
- Տեսակ: Սառցե արբանյակ խիտ մթնոլորտով
- Մթնոլորտ: Ազոտ (95%), Մեթան (4.9%)
- Մակերևույթի հեղուկներ: Հեղուկ մեթան/էթան
- Ջերմաստիճան: Միջինը -179°C
- Տրամագիծ: 5,150 կմ`,
        // ** ՈՒՂՂՈՒՄ **: Փոխվել է տեսախցիկի դիրքը՝ ավելի ճիշտ անկյուն ապահովելու համար։
        cameraOffset: new THREE.Vector3(2, 2, 3),
        isPlanetTarget: false
    }
];

// --- TWEEN PERFORMANCE (For Self-Contained Animation) ---
var TWEEN = {
    _tweens: [],
    add: function(tween) { this._tweens.push(tween); },
    update: function(time) {
        if (this._tweens.length === 0) return false;
        var i = 0;
        while (i < this._tweens.length) {
            if (this._tweens[i].update(time)) { i++; }
            else { this._tweens.splice(i, 1); }
        }
        return true;
    }
};
TWEEN.Tween = function(object) {
    this._object = object; this._valuesStart = {}; this._valuesEnd = {};
    this._duration = 1000; this._startTime = 0; this._onCompleteCallback = null;
    this.to = function(properties, duration) {
        this._valuesEnd = properties;
        if (duration !== undefined) this._duration = duration;
        return this;
    };
    this.start = function(time) {
        TWEEN.add(this);
        this._startTime = time !== undefined ? time : Date.now();
        for (var property in this._valuesEnd) {
            if (this._object[property] !== undefined) {
                this._valuesStart[property] = this._object[property];
            }
        }
        return this;
    };
    this.onComplete = function(callback) { this._onCompleteCallback = callback; return this; };
    this.update = function(time) {
        var property, elapsed, progress, value;
        if (time < this._startTime) return true;
        elapsed = time - this._startTime;
        progress = elapsed / this._duration;
        progress = progress > 1 ? 1 : progress;
        progress = progress * progress * (3 - 2 * progress); // Smoothstep
        for (property in this._valuesEnd) {
            value = this._valuesStart[property] + (this._valuesEnd[property] - this._valuesStart[property]) * progress;
            this._object[property] = value;
        }
        if (progress === 1) {
            if (this._onCompleteCallback !== null) { this._onCompleteCallback(this._object); }
            return false;
        }
        return true;
    };
};

// --- INITIALIZATION ---
function initSaturn3D() {
    const container = document.getElementById('canvas-container');
    const canvas = document.getElementById('saturnCanvas');
    const width = container.clientWidth;
    const height = container.clientHeight;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(0, 8, 10);

    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(width, height);
    window.addEventListener('resize', onWindowResize);
    onWindowResize();

    const directionalLight = new THREE.DirectionalLight(0xffffff, 4.0);
    directionalLight.position.set(10, 5, 10);
    scene.add(directionalLight);
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambientLight);

    saturnGroup = new THREE.Group();
    saturnGroup.rotation.x = AXIAL_TILT;
    scene.add(saturnGroup);

    const planetGeometry = new THREE.SphereGeometry(SATURN_RADIUS, 64, 64);
    const planetMaterial = new THREE.MeshStandardMaterial({ color: 0xe0c46b, roughness: 0.9, metalness: 0.1 });
    planet = new THREE.Mesh(planetGeometry, planetMaterial);
    saturnGroup.add(planet);

    ringsGroup = new THREE.Group();
    saturnGroup.add(ringsGroup);
    const createRing = (innerRadius, outerRadius, color, opacity) => {
        const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 128);
        ringGeometry.rotateX(Math.PI / 2);
        const ringMaterial = new THREE.MeshStandardMaterial({
            color: color, side: THREE.DoubleSide, transparent: true,
            opacity: opacity, roughness: 0.9,
        });
        ringsGroup.add(new THREE.Mesh(ringGeometry, ringMaterial));
    };
    createRing(1.2 * SATURN_RADIUS, 1.8 * SATURN_RADIUS, 0xd0d0d0, 0.4);
    createRing(1.9 * SATURN_RADIUS, 3.0 * SATURN_RADIUS, 0xb89467, 0.9);
    createRing(3.25 * SATURN_RADIUS, 4.0 * SATURN_RADIUS, 0xe0e0e0, 0.7);

    const titanGeometry = new THREE.SphereGeometry(0.2, 32, 32);
    const titanMaterial = new THREE.MeshStandardMaterial({ color: 0xcc9966, roughness: 0.9 });
    titan = new THREE.Mesh(titanGeometry, titanMaterial);
    titan.position.copy(TARGET_DATA.find(t => t.id === 'Titan').pos);
    saturnGroup.add(titan);

    createTargets();

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.minDistance = 2.5; controls.maxDistance = 15;
    controls.target.set(0, 0, 0);
    controls.enabled = false;
    controls.update();

    updateMissionStatusUI();
    setTimeout(startMission, 2000);
}

function createTargets() {
    const markerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444, wireframe: true, opacity: 0.8, transparent: true });
    TARGET_DATA.forEach(data => {
        if (data.id === 'Titan') return; // Titan object is created separately
        const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
        marker.position.copy(data.pos);
        marker.userData = { id: data.id };
        saturnGroup.add(marker);
        targets.push(marker);
    });
}

// --- FUNCTIONS OF CAMERA ANIMATION ---
function updateCameraAnimation() {
    if (!cameraAnimation) return;
    const elapsed = Date.now() - cameraAnimation.startTime;
    let t = Math.min(1, elapsed / cameraAnimation.duration);
    t = t * t * (3 - 2 * t); // Smoothstep
    camera.position.lerpVectors(cameraAnimation.startPos, cameraAnimation.endPos, t);
    const currentLookAt = new THREE.Vector3().lerpVectors(cameraAnimation.startLookAt, cameraAnimation.endLookAt, t);
    controls.target.copy(currentLookAt);
    controls.update();
    if (t >= 1) {
        const callback = cameraAnimation.onComplete;
        cameraAnimation = null;
        if (callback) callback();
    }
}

function startCameraAnimation(targetPosition, lookAtPosition, duration, onComplete) {
    cameraAnimation = {
        startTime: Date.now(),
        duration: duration,
        startPos: camera.position.clone(),
        endPos: targetPosition.clone(),
        startLookAt: controls.target.clone(),
        endLookAt: lookAtPosition.clone(),
        onComplete: onComplete
    };
}

// --- 3D DATA PANEL (HOLOGRAM) ---
function clear3DDataPanel() {
    if (typewriterInterval) {
        clearInterval(typewriterInterval);
        typewriterInterval = null;
    }
    if (dataPanel3D) {
        if (dataPanel3D.parent) {
            dataPanel3D.parent.remove(dataPanel3D);
        }
        if (dataPanel3D.material.map) dataPanel3D.material.map.dispose();
        dataPanel3D.material.dispose();
        dataPanel3D = null;
    }
}

function create3DDataPanel(position, dataInfo, onCompleteTyping) {
    clear3DDataPanel();
    const panelWidth = 4.0;
    const panelHeight = 3.5;
    const aspect = panelHeight / panelWidth;
    const canvas = document.createElement('canvas');
    const size = 1024;
    canvas.width = size;
    canvas.height = size * aspect;
    const context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 40, 0.85)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.strokeStyle = '#34d399';
    context.lineWidth = 15;
    context.strokeRect(0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.0, depthTest: false });
    dataPanel3D = new THREE.Sprite(material);
    dataPanel3D.scale.set(panelWidth, panelHeight, 1);

    const offset = new THREE.Vector3(2.5, 0.5, 0);
    dataPanel3D.position.copy(position.clone().add(offset));
    saturnGroup.add(dataPanel3D);

    new TWEEN.Tween(dataPanel3D.material).to({ opacity: 1 }, 500).start(Date.now());
    typewriterEffect(dataPanel3D, dataInfo, context, size, panelWidth, panelHeight, onCompleteTyping);
}


function typewriterEffect(sprite, fullText, context, canvasSize, panelWidth, panelHeight, onComplete) {
    const padding = 50;
    const lineHeightPx = 40;
    const fontSize = '24pt';
    context.font = `bold ${fontSize} Inter, sans-serif`;

    const maxWidth = canvasSize - padding * 2;
    const contentHeightPx = canvasSize * (panelHeight / panelWidth) - padding * 2;

    const paragraphs = fullText.trim().replace(/\r/g, '').split('\n');
    let lines = [];

    paragraphs.forEach(paragraph => {
        let words = paragraph.trim().split(/\s+/);
        if (words.length === 1 && words[0] === '') {
            lines.push('');
            return;
        }
        let currentLine = '';
        words.forEach(word => {
            let testLine = currentLine + word + ' ';
            if (context.measureText(testLine).width > maxWidth && currentLine.length > 0) {
                lines.push(currentLine.trim());
                currentLine = word + ' ';
            } else {
                currentLine = testLine;
            }
        });
        lines.push(currentLine.trim());
    });

    const maxLines = Math.floor(contentHeightPx / lineHeightPx) - 1;
    if (lines.length > maxLines) {
        lines = lines.slice(0, maxLines);
        if (lines[maxLines - 1] && lines[maxLines - 1].length > 3) {
            lines[maxLines - 1] = lines[maxLines - 1].substring(0, lines[maxLines - 1].length - 3) + '...';
        }
    }

    let lineIndex = 0;
    let charIndex = 0;

    const renderText = () => {
        context.clearRect(padding, padding, maxWidth, contentHeightPx);
        context.fillStyle = 'rgba(10, 20, 40, 0.85)';
        context.fillRect(padding, padding, maxWidth, contentHeightPx);
        context.font = `bold ${fontSize} Inter, sans-serif`;
        context.fillStyle = '#34d399'; // Animation uses a bright color
        context.textAlign = 'left';

        let y = padding + lineHeightPx * 0.8;
        for (let i = 0; i <= lineIndex && i < lines.length; i++) {
            let textToWrite = lines[i];
            if (i === lineIndex) {
                textToWrite = textToWrite.substring(0, charIndex);
            }
            context.fillText(textToWrite, padding, y);
            y += lineHeightPx;
        }
        sprite.material.map.needsUpdate = true;
    };

    typewriterInterval = setInterval(() => {
        if (lineIndex >= lines.length) {
            clearInterval(typewriterInterval);
            typewriterInterval = null;

            // ** ՈՒՂՂՈՒՄ **: Երբ գրելն ավարտվում է, վերջնական տեքստը նկարում ենք ավելի մուգ, ընթեռնելի գույնով։
            context.clearRect(padding, padding, maxWidth, contentHeightPx);
            context.fillStyle = 'rgba(10, 20, 40, 0.85)';
            context.fillRect(padding, padding, maxWidth, contentHeightPx);
            context.font = `bold ${fontSize} Inter, sans-serif`;
            context.fillStyle = '#10b981'; // Darker, more readable color
            context.textAlign = 'left';
            let y = padding + lineHeightPx * 0.8;
            for (let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], padding, y);
                y += lineHeightPx;
            }
            sprite.material.map.needsUpdate = true;


            if (onComplete) onComplete();
            return;
        }

        if (charIndex < (lines[lineIndex] ? lines[lineIndex].length : 0)) {
            charIndex++;
        } else {
            charIndex = 0;
            lineIndex++;
        }
        renderText();

        if (lineIndex >= lines.length) {
            clearInterval(typewriterInterval);
            typewriterInterval = null;
            if (onComplete) onComplete();
        }
    }, 30);
}


function createScanningLine(targetPosition) {
    if (scanningLine3D) saturnGroup.remove(scanningLine3D);
    const length = 1.5;
    const height = 0.05;
    const lineGeometry = new THREE.BoxGeometry(length, height, height);
    const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff4444, transparent: true, opacity: 0.9 });
    scanningLine3D = new THREE.Mesh(lineGeometry, lineMaterial);
    scanningLine3D.position.copy(targetPosition);
    scanningLine3D.rotation.z = Math.PI / 4;
    scanningLine3D.scale.set(0.001, 1, 1);
    saturnGroup.add(scanningLine3D);

    new TWEEN.Tween(scanningLine3D.scale).to({ x: 1.0, y: 1.0, z: 1.0 }, SCAN_DURATION).start(Date.now());
    const diagonalOffset = length * 0.5;
    new TWEEN.Tween(scanningLine3D.position).to({
        x: targetPosition.x + diagonalOffset * Math.cos(Math.PI / 4),
        y: targetPosition.y + diagonalOffset * Math.sin(Math.PI / 4),
        z: targetPosition.z
    }, SCAN_DURATION).start(Date.now());
}

// --- MISSION MANAGEMENT LOGIC ---
function startMission() {
    document.getElementById('mission-log').style.opacity = '0';
    document.getElementById('mission-status').style.opacity = '1';
    if (currentTargetIndex < TARGET_DATA.length) {
        processTarget(TARGET_DATA[currentTargetIndex], false);
    } else {
        missionComplete();
    }
}

function processTarget(target, isManual = false) {
    let targetObject = target.id === 'Titan' ? titan : targets.find(t => t.userData.id === target.id);
    if (!targetObject) return; // Exit if target not found
    
    const markerPosition = new THREE.Vector3();
    targetObject.getWorldPosition(markerPosition); // Use world position to handle rotation correctly

    missionState = isManual ? 'animating_manual' : 'animating';

    const lookAt = markerPosition.clone();
    const cameraOffset = target.cameraOffset.clone();
    // Since we use world position, we don't need to transform the offset
    const newCameraPosition = lookAt.clone().add(cameraOffset);

    startCameraAnimation(newCameraPosition, lookAt, ANIMATION_DURATION, () => {
        if (!isManual) {
            startScanning(target, markerPosition);
        } else {
            revealData(target, markerPosition, true);
        }
    });
}

function startScanning(target, position) {
    missionState = 'scanning';
    createScanningLine(position);
    document.getElementById('mission-status').style.opacity = '0';

    setTimeout(() => {
        if (scanningLine3D && scanningLine3D.parent) {
            scanningLine3D.parent.remove(scanningLine3D);
        }
        revealData(target, position, false);
    }, SCAN_DURATION);
}

function revealData(target, position, isManual) {
    missionState = isManual ? 'reading_manual' : 'reading';

    create3DDataPanel(position, target.info, () => {
        const panelWorldPos = new THREE.Vector3();
        if (!dataPanel3D) return;
        dataPanel3D.getWorldPosition(panelWorldPos);

        // ** ՈՒՂՂՈՒՄ **: Օգտագործվում է isManual փոփոխականը՝ տեսախցիկի ճիշտ հեռավորությունը որոշելու համար։
        const zoomDistance = isManual ? MANUAL_CAMERA_ZOOM_DISTANCE : CAMERA_ZOOM_DISTANCE;
        const cameraDirection = new THREE.Vector3().subVectors(camera.position, panelWorldPos).normalize();
        const finalCameraPos = panelWorldPos.clone().add(cameraDirection.multiplyScalar(zoomDistance));

        startCameraAnimation(finalCameraPos, panelWorldPos, ZOOM_DURATION, () => {
            setTimeout(() => {
                document.getElementById('mission-log').style.opacity = '0';
                if (!isManual) {
                    finishTarget(target);
                } else {
                    finishManualScan();
                }
            }, READ_DURATION);
        });
    });
}


function finishTarget(target) {
    clear3DDataPanel();
    target.status = "ՎԵՐԱԿԱՆԳՆՎԱԾ";

    const marker = targets.find(m => m.userData.id === target.id);
    if (marker) marker.visible = false;

    updateMissionStatusUI();
    currentTargetIndex++;

    if (currentTargetIndex < TARGET_DATA.length) {
        startCameraAnimation(new THREE.Vector3(0, 8, 10), new THREE.Vector3(0, 0, 0), ANIMATION_DURATION / 2, () => {
            document.getElementById('mission-status').style.opacity = '1';
            startMission();
        });
    } else {
        missionComplete();
    }
}

function finishManualScan() {
    clear3DDataPanel();
    startCameraAnimation(new THREE.Vector3(0, 15, 15), new THREE.Vector3(0, 0, 0), 1000, () => {
        document.getElementById('mission-status').style.opacity = '1';
        missionState = 'complete';
        controls.enabled = true;
    });
}

function missionComplete() {
    missionState = 'complete';
    startCameraAnimation(new THREE.Vector3(0, 15, 15), new THREE.Vector3(0, 0, 0), 2000, () => {
        controls.enabled = true;
        document.getElementById('mission-status').style.opacity = '1';
    });

    document.getElementById('mission-log').style.opacity = '1';
    document.getElementById('log-title').textContent = 'ԱՌԱՔԵԼՈՒԹՅՈՒՆՆ ԱՎԱՐՏՎԱԾ Է';
    document.getElementById('log-content').innerHTML = `
        <p class="text-xl font-extrabold text-green-400">ՇՆՈՐՀԱՎՈՐՈՒՄ ԵՆՔ, ՀՐԱՄԱՆԱՏԱՐ։</p>
        <p class="mt-2">Դուք հաջողությամբ վերականգնել եք Սատուրնի համակարգի բոլոր հիմնական գիտական տվյալները։</p>
        <p class="mt-2 text-yellow-300">Այժմ կարող եք սեղմել աջ մենյուի վրա՝ տվյալները կրկին դիտելու համար։</p>
    `;

    setTimeout(() => {
        document.getElementById('mission-log').style.opacity = '0';
    }, READ_DURATION);
}

window.manualScan = function (targetId) {
    if (missionState !== 'complete' && missionState !== 'idle') return;
    controls.enabled = false;
    const target = TARGET_DATA.find(t => t.id === targetId);
    if (!target) return;
    
    let targetObject = target.id === 'Titan' ? titan : targets.find(t => t.userData.id === target.id);
    
    processTarget(target, true);
};

// --- UI UPDATE ---
function updateMissionStatusUI() {
    const list = document.getElementById('target-list');
    list.innerHTML = '';
    TARGET_DATA.forEach((data, index) => {
        const isCurrent = index === currentTargetIndex && missionState !== 'complete';
        const isCompleted = data.status === "ՎԵՐԱԿԱՆԳՆՎԱԾ";
        const statusColor = isCompleted ? 'text-green-500' : (isCurrent ? 'text-yellow-500' : 'text-red-500');
        const icon = isCompleted ? '✅' : (isCurrent ? '🔄' : '🔴');
        const clickAction = isCompleted || missionState === 'complete' ? `onclick="manualScan('${data.id}')"` : '';
        const cursorStyle = isCompleted || missionState === 'complete' ? 'manual-scan-item' : 'cursor-default';
        const currentHighlight = isCurrent ? 'bg-yellow-800/20 border-l-2 border-yellow-500' : '';

        list.innerHTML += `
            <div class="p-2 rounded-md transition ${currentHighlight} ${cursorStyle}" ${clickAction}>
                <p class="font-bold">${icon} ${data.name}</p>
                <p class="text-xs ml-6 ${statusColor}">${data.status}</p>
            </div>
        `;
    });
}

function onWindowResize() {
    const container = document.getElementById('canvas-container');
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
}

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now();
    TWEEN.update(time);
    updateCameraAnimation();
    if (controls.enabled) {
        controls.update();
    }
    saturnGroup.rotation.y += 0.0005;
    ringsGroup.rotation.z -= 0.0001;
    titan.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.001);
    renderer.render(scene, camera);
}

initSaturn3D();
animate();

</script>
</body>
</html>